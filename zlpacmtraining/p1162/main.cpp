#include <bits/stdc++.h>
using namespace std;
int a[32][32],b[32][32];
int dx[4]= {-1,1,0,0};
int dy[4]= {0,0,-1,1}; //第一个表示不动，是充数的，后面的四个分别是上下左右四个方向
int n,i,j;
void dfs(int p,int q)
{
    int i;
    if (p<0||p>n+1||q<0||q>n+1||a[p][q]!=0)//相当于外围围了一个套子，所以判断0，n+1；不然外围的算不到
        return;//如果搜过头或者已经被搜过了或者本来就是墙的就往回
    a[p][q]=1;//染色,这里的染色是把没有围住的点染色，太强了的方法。

    for (i=0; i<=3; i++)
        dfs(p+dx[i],q+dy[i]); //向四个方向搜索
}
int main()
{
    cin>>n;
    for (i=1; i<=n; i++)
        for (j=1; j<=n; j++)
        {
            cin>>b[i][j];//其实不拿两个数组也可以，不过我喜欢啦
           if (b[i][j]==0)
                a[i][j]=0;
            else
                a[i][j]=1;//a[i][j]=2也可以，只要不等于0就行
        }
    dfs(0,0);//搜索,必须从0,0开始搜，不然最外围的有些0可能搜不到
    for (i=1; i<=n; i++)
    {
        for (j=1; j<=n; j++)
            if (a[i][j]==0)
                cout<<2<<' ';//如果染过色以后i，j那个地方还是0，说明没有搜到，就是周围有墙，当然就是被围住了，然后输出2
            else
                cout<<b[i][j]<<' ';//因为被染色了，本来没有被围住的水和墙都染成了1，所以就输出b[i][j]
        cout<<'\n';//换行
    }
}
